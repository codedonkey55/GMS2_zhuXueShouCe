GameMakerStudio2助学手册

[toc]

本手册发布时已经基本施工完毕，并非半吊子弃坑教学，请放心食用。目前已经托管给社区维护，内容会越来越丰富。
建议你下载后进行阅读，因为这样可以使用自己喜欢的主题，并能正常显示出精心编排的目录，目录很重要。

下载方法：可以右键raw-从链接另存为下载，下载后格式为md文件。以火狐浏览器为范例。



# 纯新手必读前言

GMS2可以快速制作2D游戏，相较免编程引擎更专业，相较专业引擎更简单。当前版本已支持中文界面和机翻文档，Steam购买比官网便宜。建议先下载30天试用，试用版和正式版没有区别，但不能导出，想导出游戏的时候再买。本手册仅提供给有最基本编程基础的人看，甚至许多敌方还会帮你复习最基本的语法。但如果完全不会编程就去搜一个python入门一周就学会了，学到明白函数的意思即可，不用学深，更不用学复杂的面向对象。

本助学手册涵盖了引擎知识和各种知识概念，常用函数和其他技巧。足够让新手达到以下程度：遇到不会的内容可以通过官方机翻的手册短时间解决。因侧重点不同，所以你想开发游戏的功能实现思路在本手册里可能未涉及。比如别人没讲的多人联机在我这里却有。



## 感性认识该引擎制作游戏的大致过程

- 制作素材然后导入。由于是2D游戏，素材都是年轻人不陌生的文件格式，如图片、音频等。GMS也自带画图工具，懒得单独画的可以用引擎自带的工具。

- 制作对象。GMS存爱对象和实例两种概念。如果你会VB6.0或易语言。那么对象就是工具栏的按钮模板，实例就是你吧它拖到编辑区后的按钮1、按钮2、按钮3。换到游戏开发领域里就是，怪物1，怪物2，木门1，木门2。不过相反的，制作游戏会让你大量关注对象属性，而不是拖动进来后只修改实例属性。毕竟游戏是五颜六色的艺术，要官方给你的几十个对象肯定是不够用的。

- 制作房间。房间就是其他引擎里的场景，几乎所有东西只有拖到房间这个舞台里才会生效。不然只是备用的素材。虽然名义上叫房间，但没有比房间更大的场景，比如城区、大洲、星球。都是没有的。

- 编写代码。游戏要想运动，必须有代码驱动，否则场景只能观赏，没有互动能力。比如按了D键人物的坐标会往右移动，A撞到了B会发生什么事，A开枪的时候，子弹会从哪里出来，多大的速度。敌人碰到子弹会有什么反应等。

  

## 在该引擎中，做出游戏哪些东西必须要会

必须要会的如下：

- 编程语言。要有最基本的编程能力，可以不会面向对象，甚至函数编程都不需要会。
- 引擎的使用。难度大概是学习2个微软word。当然如果你完全不会编程，就得翻倍了。

严格上讲并非必须：

- 优雅的算法：不会优雅的算法可以用粗糙的昂长代码代替。
- 单独管理的脚本（GMS其实是函数）：入门函数比面向对象简单的多，甚至有基本的编程能力就会函数，但仍不是必须，你仍可以把代码写在同一个代码页里。
- 过得去的美工能力：有一种人不会美工也不会编程，这很绝望吗？实际上你还是要和美工一起去学编程，美工可以外包，也可以凑活做，因为学习难度曲线平滑的多。
- 音乐，典型的完全可以外包的项目。如果你一定要全盘操刀也不是不可以，创作音乐比学美术要陡峭。无论如何，美术和音乐创作都是艺术，编程是技术。技术没有包容空间，错了就是错了。思想是知识，知识指导工作，让你控制好游戏设计的格局。单凭思想知识不能实际实现理想的产品。
- 英语英文，属于技术的一种，下文中会说到。



## 推荐学习渠道

- 我为新手挑选的几个用于对引擎进行基础认知的课程是：1、[红色激情gms2教程](https://www.bilibili.com/video/BV1TW411x7PC?from=search&seid=9198568433630243192)中RPG游戏分P之前的课程。大概2天学完。2、另一位叫[顺子分享的课程](https://www.bilibili.com/video/BV1ex411Y7H2?from=search&seid=16128631957076312194)，是翻译后的官方入门系列教学。两个课程做的案例都是一个上帝视角的射击打怪游戏，对引擎认知比较全面。建议你一定要去观看，因为精力原因，我写的不是多么循序渐进的入门流程手册，所以你需要有个最基本的认识再来看本手册。看完视频后，务必要实操1-2次，除非你的能力异于常人，游戏制作是一门技能不是学术，技能只有一个捷径就是多上手。边做边学。

- 在确定对GMS2软件中意准备学习后，找一个人互相监督和帮助。有人更擅长美工，有人擅长策划，有人擅长程序思路。如果你想提前结束小组，做完第一个游戏后也就毕业了，那时已掌握75%以上的软件操作。剩下的慢慢啃不太陡峭。如果你没有游戏计划，或当前技术没法开始你的想法，就制作一个练习DEMO，不要在美工音乐上浪费时间。本软件的学习量就是30%的引擎使用和70%的GML函数使用。双人小组不适合所有人，尤其是两种人：1、内向的人一个钻研更轻松的，那就别找小组。2、没有任何团队能力的人，导致双人扎堆后效率更低了。

- 帮忙其他人学习游戏制作，最好不要开QQ群，而是写小文章、文档上传到公共网络上。有些人把教学弄成加入QQ群专属的福利，很难相信这些人是真的想造福其他人。

  

## 编程和英语困难者怎么办

- 关于英语

先说结论，不会英文英语是可以正常开发游戏的，尤其是本手册的诞生。

编程用到的主要是英文而不是英语，所以学校里教的哑巴英语是可以用的。不会英语不会导致游戏做不出来，但会导致学习资料不好查。但要记住，不会更糟了，是不好查而不是不能查。你的学习速度要变慢40%以上。一定要使用翻译软件，推荐你使用Deelp、有道。这些比谷歌百度效果更好一些。想要尽可能抵消这个劣势，就不能手懒，多翻译。可以扭转10%的劣势。事实上，人是情感的动物，更多的人不是速度变慢了，而是放弃了，因为他们不相信是减速，而是相信根本行不通。

- 关于编程

不会编程的人不要使用可视化蓝图功能，因为它们都是一种东西，蓝图还更混乱不直观。被认为最难的C++都是简单的，五天就学会。难的是程序设计思维，和做数学题一样，计算方法都会，但有一个甲乙双方同时施工的实战题让你给出数学解答的思路，编程和数学难的都是这一部分。



## 学习时间参考

有编程经验的人可以在一周时间学完然后上手做中低难度的游戏，有不会的可以在制作中边学边做。没有任何编程经验的人是一个月。但不要被参考时间导致心理暗示，有经验的人可能好一月才能上手做，因为看教学不认真看，或者精力投入太低，性格原因等。英语水平达到四级和找学习搭档会显著缩短时间。



该篇资料仅为实用，收录的资料很多，也没有写清楚转载的是谁，修改了什么内容。对应的，我本人也没留名或用来盈利。大多数资料还是我自己手写的，它们读起来应当是比较浅显易懂了。那些难懂或粗制滥造的教学我也没有收录。

## 和虚幻4对比

我知道游戏制作纯新手对这样的话题很关心。就来陪你们聊聊。在没有本手册出现前，对于一部分学习能力不高的国人来讲（指的是对零散资料缺乏整理能力，英语不好，自学能力差，不翻墙等），做出同样的游戏，虚幻4和GMS2的学习难度差不太多。主要原因是虚幻在教学尤其是本土化教学上投入多，高于主流引擎商的平均水平。而GMS的制作组懈怠，略低于主流引擎商的平均水平。我做这个手册还是有斟酌的。因为GMS搞了一个意义不明的联网验证迫害正版受害者，又是一个收费引擎，为了什么要给它无偿工作呢？2D游戏表达艺术的空间相较3D是明显有限的，三维世界的玩家进入二维世界会自带代入感的损失。如果你的心中只想做3D场景就去学学虚幻4蓝图编程吧。最终我把手册发了出来，是因为还是能帮到一些人的，在本手册出现前，我真的会劝别人好好考虑要不要用虚幻4的。我能找到GMS一个明显优点就是它能更有效培养编程能力为之后的选择铺平道路，让人对引擎使用从零基础入门到精通，编程水平从小白变成能入行的新手，是一件靠谱的事。



# GML语言

gml是一种极弱类型的脚本语言。对于学习过C系语言的人来说，语法可以直接跳过，只看引擎的函数。这篇笔记也不写编程入门。编程入门简单，翻一个python入门教学几天弄明白。但这里就不写了，比如编程中的变量、函数、关键字是什么意思。

在IDE中，黄色是函数或关键字，绿色是某个对象/示例的属性，浅蓝色是某个对象/实例的变量，红色是常量。



## 变量范围

**GML分为：临时变量、实例变量、全局变量。还有一个常量**

- 临时变量。用var声明。也叫事件变量。一旦函数或事件结束就自动销毁。var适用于性能优化，循环语句，统一修改值等。

- 实例变量。直接声明即可。多个实例的实例变量可以是重名的，数据各自独立。但只能在自己的实例中访问自己。寿命是从实例创建后，到实例销毁时，但无需考虑寿命，因为无论是死是活，其他地方的代码都无法访问。

- 全局变量。用global.声明。是不绑定实例的，所有脚本都可以访问该变量一直到程序关闭。声明方法：global.变量名 = 5。GMS内置了一些全局变量，只为兼容老版本，官方不推荐使用，比如health，live，score。



- 常量，用#maco声明。声明后不能再改它的值，常量和枚举有共同之处，在逻辑上并不是必要的，只是为了增加程序的人类可读性。适合做圆周率和各种固定的物理数据等。或者主角的有三个动画，如果不用常量，就是0代表正常，1代表走路，2代表攻击。刚刚做完还记得，等几天后就忘掉了。如果用常量就是 image_index = ZOULU;这个ZOULU对于计算机来讲实际上代表的是数字1。注意，常量不能在函数里调用。



## 数据类型

作为弱语言，GML的数据类型也很弱。默认为全自动，无需声明。

GML的数据类型就两种：

- 数字类型：不区分整数，浮点数。且充当了布尔值，GML没有布尔型，但可以用常量true和false表达相同意思。具体来讲可能是正数为真，0和负数为假。
- 字符串类型：就是文字。

没有隐式转换，需要转换的时用string()，比如"hello" + string(1234)

用noone表达空的、不存在的意思，相当于某些编程语言的null。



那么，既然GML只有数字和字符串两种类型，引用的资源和实例是什么类型？

答：也是纯数字，尽管在编辑器里显示的是英文数字混合的。

GMS中每个实例创建后都有一个 自身的ID，ID像身份证一样能找到具体唯一的实例。如果这个对象被实例化后充当是一个景色比如一棵树，那么你没必要关注它的ID，但如果是一个功能性的物体，就要有办法知道它的ID不然之后代码将对它失去控制。有各种方法可以知道ID，比如创建实例化的时候就会返回一个ID给你，碰撞事件 发生时候也会返回对方的ID等。



```c
//假设qiao2_ID是某个实例的ID
if(global.qiao2_ID != noone)
{
    global.qiao2_ID.y -= 100; //如果qiao2_ID存在room中，就让他向上移动。不存在就不执行，你可能会说如果不存在不就无效吗？为什么还需要判断是否存在。但对于gms和多数引擎输出后的程序来讲，就会因为找不到实例而崩溃。
}
```

## 数组

数组让游戏开发更高效，性能更强，减少变量重名。比如做背包系统，有20个格子，就是1个数组20个元素。

- 一个数组可以包含不同的变量类型的元素。比如数字，文本。布尔。别忘了布尔也是数字。
- 数组从0开始。shuzu[0] = 50，shuzu[1] = “hello world”，shuzu[2] = true。
- 数组可以作为变量，也可以作为数据结构使用。
- 创建数组时要赋值以初始化，一般给0，如shuzu = [0,0,0,0]。创建了四个元素都是0。或shuzu[3] = 0
- 二维数组就是像xy坐标那样确认一个元素。比如 shuzu[1,1] = "hello"。就是横数第二个且竖数第二个的那个元素。

> GML的官方数组不够高级，甚至不能获取数组长度。不过GML提供了列表、字典。操控它们的函数都是ds_开头。

## 关键字

大多数关键词和其他常见语言一样，不过有的地方还是啰嗦了一点，是为了方便复习记忆，不用去网上搜来搜去，比如switch不写break结果导致错误，排查半天才知道是低级错误。

```c
//if判断。和常见语言一样。还可以像python一样不写小括号。
if(a = 0){执行语句;}
else if(a = 10){执行语句;}
else{执行语句;}


//switch判断。和常见语言一样。case就是else if，default是else。千万别忘了加break，不然会执行之后所有的case，不管逻辑是否满足。很反人类的。
     switch (chengJi){
        case "A":show_message("80~90分！"); break;
        case "B":show_message("70~80分！"); break;
        case "C":show_message("60~70分！"); break;
        default: show_message("0~30分！"); 
     }


//while循环。和常见语言一样。如果满足括号内的条件就是一直循环。
while(a < 100){
    a ++;
}


//do-until循环。和其他语言的do-while用法一样。在do里先进行一次无条件循环，然后看until括号里的条件是否满足，不满足继续循环。

sum=0; 
i=1; 
do
{
   sum += i;
   i += 1;
}
until(i>100)

 
//for循环。和常见语言一样。
for(var i = 0;i < 50;i ++){
    
}

//repeat循环。是GML方便游戏设计自制的。repeat(循环次数)
repeat(5){
    a ++;
}


//with。括号里填入对象名或ID。在大括号内可以暂时操控这个对象或实例。或者说，在大括号里你就相当于在被with的实例或对象里写代码。可以调用任何属于它的属性、变量等。
with(wanJia_id){
    x ++;
    y ++;
}



//try/catch/finally异常处理。和常见语言相同，简单而优雅。try大括号里的代码是程序正常执行的部分，catch大括号里的代码是try内的代码出现会让游戏崩溃的问题时执行，否则不执行。finally一般不用，它里面的代码是无论try有没有异常都会绝对执行，且只能写在catch后面。
try{
    mingZi = wanJiaShuRu;
}
catch{
    show_message("错误！您没有输入任何文本")
}
finally{
    //略
}


//exit不再执行之后的语句。
//如果你在函数中使用，将不再执行函数内之后的语句也就会关闭函数，有点类似return。
//如果你是在对象的事件中使用，将不再执行当前事件之后的语句。
if(aaa = noone){exit;}//如果aaa还没有被赋值，之后的代码都先不要执行。
xxxxxxxxxxxx{
    xxxxxx;
    xxxx;
}



//break。和常见语言类似。用于提前结束任何一种循环和中止switch判断。如果你想让一页代码不再继续执行剩余的所有语句，应该看看exit而不是break。


//continue。和break的区别是，break是中止循环和判断。continue是跳过本轮循环立刻开始下轮，且只能用于循环语句。


//return。一般是在函数里使用。括号内写要返回值的值。且出现return后，脚本不会再往后执行而是立刻结束。
return(a + b);

//throw。强制引发一个游戏崩溃的错误框，括号内输入一个用于显示的文本。
throw("Hello");

//new。待维护。不是要用new来实例化某个对象，实例化对象是用instance_create()。

//delete。待维护。似乎是用于删除某类结构的。


//美化用途的折叠代码。看喜好选择性使用，有的人不喜欢折叠一层层的。
#region
a = 1;
b = 2;
#endregion

//begin/end。代替大括号或者说是花括号的关键字。可能是照顾VB用户。

```

下面还有一些叫做实例关键字的关键字。使用时要注意上下文，因其含义明显受到上下文影响。

```c
//self。相当于把自己的实例ID。但并不是ID，且比调用ID性能更好。如果你想用self查找自己的ID同样可以，使用self.id。我在制作游戏中没用到过它，因为实例的变量都是可以直接写的。比如x,y,speed。也许它们就是self.x被自动省略了。
var linShi_ID = self.id;		//快速读取到自己的ID


//other。你可能会疑问为什么gml能这么自信知道谁是“其它实例”。实际上这个other主要就是碰撞事件中发生碰撞的另一方。
with(other){
    instance_destroy();			//反物质子弹，碰到谁谁死
}


//all。意思大概是指房间里所有处于正常工作状态的实例。
with(all){
    x += 5;						//让房间里所有实例朝右挪动一点。	
}


//nonne。空的，相当于null，其他地方已经提到过了。
if (name = noone){show_message("还没有取名，因此你不能进入游戏");}
```



## 枚举

枚举是一种用户自制的数据类型，用于增加代码可读性。能够使用人类的自然语言，而不是数字。关键词是enum。如果不选择使用枚举，则要用1代表男人，2代表女人。枚举和常量效果类似，枚举字数多一些，但能在函数内调用，应根据需求选择。

```c
//制作一个叫xingbie的新数据类型。改数据类型全局有效。就像布尔值数据类型那样，true的本质是1，false的本质是0，只是代替为了人类易读的英文。
enum xingBie {nan = 1,nv = 2};
//使用时，直接把这种数据类型赋值给需要的变量，无需数字代表。
wanJia_xingBie = xingBie.nan;
if(wanJia_xingBie == xingBie.nan)
{
    show_message("你目前选择是男性角色")
}
if(wanJia_xingBie == xingBie.nv)
{
    show_message("你目前选择的是女性角色")
}

```



## 运算符

数学运算符：+ - * / 加减乘除和其他语言一样。还有mod求余数，div整除。

```c
a = 10 mod 3 //结果是1，其他语言里的%，两数相除取余数。
a = 10 div 3 //结果是3，其他语言里的\，两数相除取商数。
```

比较运算符：> < >= <= != ==。有时候在if里写成单个等于号也可以，不会变成赋值报错。

逻辑运算符：支持英文和符号两种，可以写!或not，&&或and，||或or 。建议用英文写直观。



## 脚本就是全局的函数

函数也叫方法。在gms引擎里脚本其实就是函数的意思，方便复用。GMS的函数需要再创建一个单独脚本文件，且传进来的是一个叫argument的数组。数组中最多16个元素，不支持重载。GMS中一个脚本里不能使用其他脚本，这点不太好，比如你有一个脚本专门用来定义常量，那么在这个脚本你就只能用原始的数字0，1，2，3，4代表了。尽管常量在这种情况下可以用枚举有效代替。

脚本名就是函数名。比如scr_qiuHe(参数1,参数2,参数3)。GMS2支持给函数添加提示。没有特殊情况时，脚本要用var临时变量防止重名。

```c
return argument[0] + argument[1] + argument[2];
//稍微复杂的情况下，就要正常做脚本内容，比如
var a = argument[0];
var b = argument[1];
return a + b;
```

哪个实例调用脚本，脚本中的变量就是实例里的变量。以此弥补了GML的残废继承和没有多态的问题。比如写一个敌人死亡的脚本，可以实现死亡动画、玩家加分、掉落物品等功能。那么每个敌人死亡时都可以调用这个脚本，脚本中也可以方便读取到敌人实例的属性。

```c
x = x + 1 //谁调用了这个脚本的，谁的x就+1。
```

## 数据结构

- 数据结构就是ds_开头的那些。当你处理复杂数据时，如果不想写大量脚本，就要用数据结构。中小型游戏和离线游戏基本可以不用数据结构。并且如果要学，你也不像计算机科班学生一样学习它那么复杂和难。

  

  - 栈：stack。像一口水井，先扔下去的只能后拿出来了。即先进后出，后进先出。
  - 队列：queue。像看电影排队，先进队的先出，后进队的后出。和栈相反。
  - 列表：list。列表是用简单数组实现的。
  - 映射：map。一个键对应一个数据，这个键类似索引不是指键盘。
  - 优先队列：priority。可以设置优先级的队列。
  - 栅格：grid。记录x,y等数据，可以用二维数组代替，但不如栅格高效。

  

  数据结构函数都类似，create创建时会返回给你一个整数作为它的ID索引。用这个ID对这个创建的数据结构进行各种操作，比如destroy删除，clear清空所有数据但不删除它。copy输入两个ID，用以将B的数据复制给A。size返回指定ID储存了多少数据。





# GML语言的常用函数

我之前尝试整理官方文档，后来发现那个结构不太人性化。故重新在这里的常用函数区整理。如果你看不懂其中某段代码就再中键看一下文档。



## 硬件设备输入

```c
//某键是否按了
keyboard_check(vk_f2)
//某键是否按了一次，如果要再触发必须重按
keyboard_check_pressed(vk_f2)
//鼠标左键是否被按了
mouse_check_button(mb_left)
//鼠标左键是否被按了一次，如果再触发必须重按
mouse_check_button_pressed(mb_left)
//鼠标滑轮上或下滑动了
mouse_wheel_up/mouse_wheel_down
    
//常用WASD通用移动脚本
suDu = 1
if(keyboard_check(ord("W")))y -= suDu;
if(keyboard_check(ord("S")))y += suDu;
if(keyboard_check(ord("A")))x -= suDu;
if(keyboard_check(ord("D")))x += suDu;

//常用鼠标移动玩家朝向脚本

direction = point_direction(x,y,mouse_x,mouse_y)
image_angle = direction


//备注，vk_是某个键盘不含字母，mb_是鼠标输入，ord("W")是指定某个字母如W
```



## 实例属性

```c
实例的属性是新手很早就会接触到的。如果你要控制一个实例的,那么会用到x,y,旋转等。这些都是调用了实例的属性。那么实例有哪些属性呢，请看下方。
    
//x和y坐标。用于移动，过于常用略过
x += suDu;
//获得对象上一步\帧的坐标。利用这个属性，可以判断当前实例是不是在移动中。
if (x != xprevious and y != yprevious) {}
//获得实例在房间中最开始的位置。用法同上。
xstart和ystart;
//实例的逻辑朝向。对应的image_angle是图片的朝向。
direction = 90;
//控制实例的速度。实例按照逻辑的朝向以该速度不停前进。
speed = 2;
//用x,y轴控制实例的速度，hspeed和vspeed。和speed的区别是，它不需要看direction逻辑方向。
hspeed = 15;//水平速度，即x轴。
vspeed = 15;//垂直速度，即y轴。
//获取本实例的id。别忘了还有创建实例时也可以保存ID。
global.pingGuoID = id;
//实例的可见度。true为可见。注意不要被误导。它还有可用不可用的含义，如果不可见，那它也就没有功能。所以更像是临时移除而不是隐形。
visible = true;
//设置是否为实体。这个概念我在简易碰撞实现方案谈到过。如果一个实例是实体，并且另一个对象和它有碰撞事件为关系，那么就会产生碰撞阻挡。
solid = true;
//设置是否为保持模式。大概是指这个实例创建后，无论怎么切换房间都会一直存在，除非手动销毁它。
persistent = true;
//设置实例的深度，数字越大越底层。如果你有精准的深度要求，请看下手册并自己测试下。需要维护。
depth = -2;//设置为2后，它会比-1显示的更靠上，每逢重叠时会显示在-1的上面。
//设置实例的图层。需要维护，
layer;
//设置倒计时计时器。每个实例都有12个倒计时方便使用。到时间后就执行对应的计时器事件。这里是给0号计时器设置100帧的倒计时。如果你想停止倒计时，应该给它赋值-1而不是0。
alarm[0] = 100 


```



## 创建实例

```c
//创建一个有深度的实例，可以接收创造后的那个实例ID
instance_create_depth


//常用的发射子弹脚本
global.ziDanJianXi -= 1
if mouse_check_button(mb_left) and global.ziDanJianXi <= 0
{
	var ziDanID = instance_create_depth(x,y,-1,obj_ziDan)
	with(ziDanID)
	{
		speed = 50
		direction = other.direction; 
		image_angle = other.direction; 
		
	}
	global.ziDanJianXi = 5;
```

## 碰撞

```c
//检查x,y和obj是否有碰撞，返回布尔型。如果还需要对方ID，请使用instance_place，但性能会略差一些。
place_meeting(x,y,目标)

//如果x,y和obj发生了碰撞，则返回一个ID，不然返回为0。
var ID = instance_place(x,y,obj_men)

```

## 绘制

```c
//设置字体
draw_set_font(ziTi_fangSongTi)
//设置字体文本的对齐格式，分别是左、右、居中
draw_set_halign(fa_left); 
draw_set_halign(fa_right);
draw_set_halign(fa_center);
//设置字体颜色
draw_set_color(c_black)
//在屏幕的xy点绘制某段string
draw_text(50,50,"Hello")
//绘制精灵，分别是精灵索引，图片索引，xy位置
draw_sprite(spr_qiang,0,x,y)
//复杂绘制精灵，分别是精灵索引，图片索引，xy位置，x拉伸和y拉伸,旋转角度（正数为逆时针），透明度
draw_sprite_ext(spr_qiang,0,x,y,1,1,-90,c_white,0.5)
//设置透明度，1为不透明，0为完全透明。允许中间数。
draw_set_alpha(1)
//绘制自己的精灵，如果没有精灵会导致错误
draw_self()
    
//我修改了某一个绘制参数比如改了文字颜色，什么时候会恢复默认？
//答：不存在这个概念，修改后，以后的绘制命令都按照这个样式绘制，直到你手动修改回来。当然仅限一篇代码内。
```



## 操作数据格式和字符串

```c
此处将两篇整合在了一块，以后可能会分开。
    

数据格式部分：   

//将字符串转换为数字。为防错误，通常用string_digits删除含有非数字的内容。以及使用if判断string变量是不是为""(意思是是否为空字符串)，以防止空转出现错误，string_digits只会负责删除非数字内容，其他的管不到。
var nianLing = string_digits(nianLing);
global.nianLing = real(nianLing);

//将数字转换为字符串。GMS并不愿意把数字变量输出为文本。所以还要再加一个string。
draw_text(x,y,string(neiRong));

其他内容详见string（官方文档机翻成了弦乐）部分，日后再更新。

```



## 音乐和音效

```c
GMS支持ogg,mp3,wav音频格式。
GMS区分了简易音频功能和进阶音频功能，简易音频功能好上手，通常只是一段代码，不需要侦听器。
    
使用GMS音频前，你需要知道，音频也需要实例化。当你开始播放时就完成了实例化。届时，将返回给你一个实例ID供你保存。官方这样设计的目的是，方便你之后对播放中的音频进行操作，不然将失去控制权，对不对？还有一个概念是“内存音频”和“流音频”。意思据我所知是这样的，流音频对应英语stream，即从特定文件夹临时导入的音频，内存音频就是你之前在资源文件里放好的。
    
//返回音频的名称，可以是资源名,也可以实例ID。
var name = audio_get_name(snd_kaiMenSheng);
//检查音频所在的位置。如果是在“流传输”里，则返回1。如果在内存中则返回0。其他错误则返回-1。
type = audio_get_type(snd_Music_1);
//播放音频。参数1是资源名，参数2是优先级，参数3是要不要循环。优先级高的音频播放时会停止优先级低的音频。
audio_play_sound(snd_PlayerDead, 10, false);


//在指定位置的音频。如果要使用建议看看帮助文档。
//参数1是资源名，参数23是位置，参数4是z轴位置，参数5衰减参考值，参数6衰减最大距离，参数7衰减系数1，参数8音频优先级。
audio_play_sound_at(snd_Waterfall, x, y, 0, 100, 300, 1, true, 1);
//暂停指定的音频。可以有效用于 audio_play_sound和 audio_play_sound_at两种代码播放出来的音频。参数可以使用实例ID，也可以用资源名，使用资源名会导致该资源名的音频全部暂停。（废话）
audio_pause_sound(snd_Waterfall); 
//暂停所有音频。
audio_pause_all();
//从暂停中恢复播放特定音频。和上面的同理。
audio_resume_sound(snd_Waterfall); 
//从暂停中恢复播放所有音频。
audio_resume_all();
//停止指定的音频。和上面的同理
audio_stop_sound(snd_Waterfall);
//停止所有音频。和上面同理
audio_stop_all();

//检查指定音频是否在播放,可以是实例ID或资源。注意，对于暂停的音频仍然返回true。
audio_is_playing(snd_eatFood);
//检查指定音频是否是暂停状态。
audio_resume_sound(snd_eatFood); 
//从本地导入一个.ogg音频使用。注意之后一定要删除，不然会损失性能甚至内存泄露。
snd_eatFood = audio_create_stream("Music/eatFood.ogg");
audio_play_sound(snd_eatFood, 0, true);
//删除一个流音频。对应上方。
audio_destroy_stream(snd_eatFood);
//设置音频播放的初始秒位置。如果用于操控实例ID大概将立刻生效到要求的位置，如果是资源则在下次播放时有效。
audio_sound_set_track_position(snd_eatFood, 2);
//得到音频播放的进度，以秒为单位。比如正播放到14秒。只能用于实例ID。
var weiZhi = audio_sound_get_track_position(eatFood_ID);
//得到音频的总长度，以秒为单位。
len = audio_sound_length(snd_Beam);
//修改音高，默认为1.0。使用时详见文档。
audio_sound_pitch(s_engine, 1.2); 


```

## 外部文件操作

```c
此部分官方文档叫文件处理。这些函数对工具软件很有用，就像不能修改自身以外文件的软件，一般都是没有意义的。但是对于游戏软件不重要，游戏主要使用ini这种函数来保存游戏设置或建立存档。来让游戏和那些工具软件一样同样有记忆性。
    
ini文件：
ini是小型轻便的文件，和多数平台兼容。是储存少量信息的理想选择，例如游戏设置，分数记录，关卡打到了第几关。最大可以储存64KB的内容，也不是太少。取名时不要用options.ini不然将会冲突，因为游戏编译后会生成这个文件。如果你要储存汉字和非英文字母，可能需要事先制作好UTF8格式的ini文件。

ini的格式是简单而优雅的映射格式。一个映射名/键名(key)对应一个值，使用的时候直接用映射名读写。此外，还有章节之分，你在读写时要告诉程序是在哪一个部分。ini文件格式如下：
[画面设置] 				//这个就是章节部分名，也叫section
分辨率高 = 600
分辨率宽 = 800
是否全屏 = true
[声音设置] 				//这个就是章节部分名，也叫section
主音量 = 100
环境音量 = 100

常用的ini函数：
 
//打开一个ini文件文件。如果没有则创建同名文件，前提是你之后有写入的代码数据。一次性只能打开一个ini文件，使用ini_close()将关闭当前文件，且在运行此函数后才会真正修改文件。
ini_open("saveData.ini"); 
//关闭当前的ini文件。因为只能同时打开一个，所以只能是关闭当前的。且完成读取或写入操作后一定要使用本函数。
ini_close();
//向ini写入数字。
ini_write_real("章节部分", "映射名", 123456);
//向ini写入字符串即文本。要注意若含有引号和转义符有可能会在以后读取后不正确。一般不太会用的，这也是为什么游戏往往不允许一些字符作为名称。
ini_write_string("章节部分", "映射名", "你好！");
//从ini读取数字。参数3如果是读取失败，则返回的值。
shuZi = ini_read_real("章节部分", "映射名", 0);
//从ini读取字符串。参数3如果是读取失败，则返回的值。
mingCheng = ini_read_string("Variables","string","Hello world"); 

不常用的ini函数：
    
//检查映射名/键名是否存在。这不是必要的，因为读取失败不会报错而是返回预留好的值。返回true为存在。
ini_key_exists("章节部分", "映射名");
//检查章节部分是否存在，方法同上。返回true为存在。
ini_section_exists("章节部分");
//删除一个映射/键以及它的所有值。
ini_key_delete("章节部分", "映射名");
//删除一个章节部分以及它的所有映射和所有值。
ini_section_exists("章节部分");


普通文件操作。
要注意，GMS2编译后的游戏默认在沙箱中运行，可能会导致权限不足操作失败。如果你在工程设置里禁用沙箱，那可能会被杀毒软件察觉到导致其他问题。

//检查文件是否存在。返回true为存在。
file_exists("level.txt");
//删除某问题。该函数只能删除gms能创建和解析的问题，如ini,txt,二进制文件,游戏资源文件。有返回值，返回true为删除成功。
file_delete("level.txt"); 
//重命名。有返回值，返回true为重命名成功。参数1是老名字。
file_rename("level1.txt", "level.txt");
//复制某文件到某处。不会影响原文件。
file_copy("level1.txt", "bin\level2.txt");
//待维护。
file_find_first();
file_find_next();
file_find_close();
file_attributes();
filename_name();
......


```



## 粒子

```c
//这里只写简单的预设粒子效果如何调用
//创建粒子
effect_create_below(kind,x,y,size,color) 或 effect_create_above(kind,x,y,size,color) 
//清空粒子
effect_clear()
    
//预设粒子种类。注意有些粒子需要每帧/步都要创建，比如烟雾、雨滴
ef_explosion 爆炸 
ef_ring 环形物 
ef_ellipse 椭圆 
ef_firework 烟花 
ef_smoke 烟雾 
ef_smokeup 上升的烟雾 
ef_star 星星 
ef_spark 火星 
ef_flare 闪光 
ef_cloud 烟云 
ef_rain 雨水 
ef_snow 雪花 
  
```





## 相机

```c
//让相0号机跟随自己。
camera_set_view_target(view_camera[0], self或实例ID、对象)
```



## 联网

```c

//创建一个服务器。参数1是服务器类型，参数2是端口号，参数3是允许最大客户端连接数
network_create_server(type, port, max_client);
创建TCP服务器使用network_socket_tcp，创建UDP服务器使用network_socket_udp。其他不常用;

//为客户端创建一个tcp套接字，并把ID索引保存到变量中
client = network_create_socket(network_socket_tcp);

//向目标服务器发送连接要求，需要使用参数1是套接字ID，参数2是服务器的地址，参数3是服务器的端口
//本地调试请使用127.0.0.1，因为192系列是局域网ip，地址不稳定。127永远指向自己的电脑。
network_connect(client, "127.0.0.1", 6510);

//设置服务器。比如延时等待，是否拒绝连接。参数1是要设置的项目，参数2是修改的值。
//下方代码是让服务器等待不超过1000帧。

network_set_config(network_config_connect_timeout, 1000);

//发送数据包。服务器相关函数没有接包的，接包属于异步事件的事，不关network函数的事。
//对了。无论是客户端还是服务端，接受数据一定要在异步事件里，而发送数据不建议写在异步事件里。
//参数1是对方的套接字ID，参数2是缓冲区ID，参数3是设置包的数据大小，使用get_size自动获取buffer的大小就行。

network_send_packet(服务器的socketID, buff, buffer_get_size(buff));

//踢出一个套接字ID的连接，大概是这样的。详见文档。

network_destroy(sock); 

//什么是socket。
socket是套接字的意思。服务端和客户端通信，包括服务端在内的每一个端都是一个socket。有了socketID，就像座位号一样知道对方是谁了。一般，创建服务器的服务端socketID是1，之后进来的玩家是2、3、4、5等。如果像War3房主建房的那种即开服的电脑也要加入游戏玩，一般会另外申请一个，因为工作不同不便通用。
    









```

## 异步联网



```c
GMS里的异步（async）是GMS开发商懒人化的函数，你并不需要担心这个奇怪名字。异步事件就是服务端接收到客户端数据的时候执行的操作。
在网络通讯中，只能用异步事件接收数据包，而发送数据包可以写在network或async里，尽管都建议是写在network里;
只要服务端和客户端正常连接着，异步事件就不停地触发，相当于网络版的步事件。
关于异步和同步的区别，概念章有介绍;

//获取异步事件的map映射数据结构。意思是，让map成为异步系统的影子，之后的异步操作就找map这个变量就好了。你不要管async他本人在哪里。

map = async_load;

//这个map身上有一大堆来自触发者的信息，如果是客户端上的异步事件，那么服务端是触发者。反过来就是客户端触发。包括以下信息：

type：触发者传来的消息，包括上线了、下线了、有数据包发来了;
id：一般就是指就是触发者socket的id;
ip：对方的ip，为字符串类型;
port：与对方ip地址相关联的端口，使用UDP通信时会用到;

socket：是一个特殊的信息。当触发者发来下线或上线消息时，该socket会临时存在。socket和id都是socketID。它们的区别是，这里的socket是刚刚上线或下线的socket id，而id是正常情况不停通信的socket id。不要用错了。比如每次有人上线或下线就对服务器的socketID进行删增，那么要用socket。

//现在我们需要看看网络传来的消息。

type = ds_map_find_value(map,"type");

//用switch或if对type的值进行判断

network_type_connect	   //传来消息：有客户端上线了
network_type_disconnect	   //传来消息：有客户端下线了
network_type_data		   //传来消息：有服务端发来数据包了。客户端大概只需要用到这个。







```







## 缓冲区

```c
缓冲区主要是在网络发包使用，目的是优化性能，快速储存进度也可以使用;
缓冲区必须按照顺序写入和读取，若你压入的顺序是x,y,rota,index.读取的顺序也要相同。
缓冲区的数据格式详见知识概念篇

//创建一个缓冲区，把他的ID索引存到变量里。参数1是大小，参数2是类型比如固定的，灵活的，快速的。参数3是字节对齐方式。详见文档。
player_buffer = buffer_create(16384, buffer_fixed, 2);

//往缓冲区写入一个数据，参数1是保存缓冲区ID的变量，参数2是数据格式，参数3是要存入的比如x坐标。详见文档。
buffer_write(buff, buffer_s16, x);

//读取缓冲区的数据，用到的参数和写入差不多。
var cmd = buffer_read(buff, buffer_s16);

//设定到缓冲区到最开始的位置，0是偏移字节。每次使用数据包前这样写可以防止顺序错误。
buffer_seek(buf, buffer_seek_start, 0);

//删除一个缓冲区，由于缓冲区ID都是从0开始的，为了防止之后读取错乱的情况，官方手册建议紧接着就把这个变量设为-1。注意，不要犯懒惰而来的低级失误，delete必须要完成。因为buf保存的是缓冲区ID，就像你用一个变量记录了一个实例ID一样。之后又为该变量赋值了新的ID，之前的实例怎么可能受到影响。
buffer_delete(player_buffer);
player_buffer = -1;

//从缓冲区自由选择位置读取数据，参数2是字节位置。此方法不影响顺序
var red = buffer_peek(buff, 1, buffer_u8);
var green = buffer_peek(buff, 2, buffer_u8);
var blue = buffer_peek(buff, 3, buffer_u8);


```



## 数据结构之列表

```c
列表非常类似于一维数组，但更加高效;

//创建一个list数据结构，用list接收ID索引。文档说为了提高性能，创建后实际上前几项是被赋值了的，尽管返回值仍然是0。如果想创建真空，应该接着用ds_list_clear()。

list = ds_list_create();

//删除列表，并且把原先的变量改为-1防止意外错误。文档说还要遍历所有的列表项目删除，防止内存泄漏，这么麻烦吗？

ds_list_destroy(AI_list);
AI_list = -1;

//清空列表的所有项目。和上方一样，也要遍历所有的列表项目删除。

ds_list_clear(command_list); 

//检查是否是一个空的列表，空返回true

ds_list_empty(command_list)
    
//检查列表的项目数量
    
num = ds_list_size(control_list);

//向列表添加数据，参数1是列表ID索引，参数2要放进去的内容。新放入的项目总是位于列表的最后。

ds_list_add(sc_list, score);

//删除一个项目，参数1是列表ID索引，参数2是位置。0就是最顶端的项。

ds_list_delete(sc_list, 0);

//在列表中搜索一个数据，并返回它在列表中的位置。如果没找到返回-1。如果有同名，则会只返回其中一个。

pos = ds_list_find_index(list, "Player1");

//和上面相反，是用位置得到值。如果超出范围，则返回0或Undefined。

val = ds_list_find_value(list, ds_list_size(list) - 1);

//自由的在某处插入一个新项目。参数1是列表ID索引，参数2是位置，参数3是要存入的数据。

ds_list_insert(list, 9, score);

//替换一个项目的值。参数1是列表ID索引，参数2是位置，参数3是要用以替换的新数据。

ds_list_replace(n_list, 3, name);

//随机排放列表的项目，顾名思义是洗牌。在调试时要注意重置下随机数种子，不然每次都是一样的洗牌结果。不影响打包后的游戏。其他地方也谈到过。

ds_list_shuffle(card_list); 

//复制整个列表到另一个列表，把参数2复制给参数1。

ds_list_copy(new_list, old_list);

//按照从小到大或从大到小排序，即和windows，安卓文件目录类似的方式进行排序。true为从小到大，false为从大到小。英语字母abcd排序，数字1234排序。

ds_list_sort(name_list, true);

//读和写。数据结构的读和写似乎是相反的。并且这个读写功能似乎不常用。
//从list里面写出一个字符串（没错，是写出），这个字符串不是人类读的那种字符串。
var string = ds_list_write(list);
//然后用read读入
ds_list_read(list, string);



```





# GMS常用概念

## 事件

事件和蓝图系统不一样。有些事件是可以被代码代替的，比如键盘鼠标的输入，可以在帧事件里判断。有些不能替代，比如绘制事件。甚至只能在绘制事件里使用绘制相关函数，不然会有各种问题。



- 创建事件：对象被实例化的时候，执行一次里面的代码。
- 倒计时计时器：内置了12个计时器，在其他位置定好倒计时，时间一到就执行一次这里面的代码。是个非必要功能，可以自己用代码实现倒计时，达到n个计时器的效果。
- 步事件/帧事件：每一步、帧都会执行。对性能影响也大。

- 绘制：步事件的一种。在房间里某个坐标绘制出某东西。
- 绘制GUI：步事件的一种。GUI是界面的意思，绘制出来的东西一直跟随屏幕。

- 硬件输入：这些东西用处不大，比如检测鼠标和键盘按住什么键。

## 坐标

x代表左右，数越小的越靠左，越大的越靠右。

y代表上下，数越小的越靠上，越大的越靠下。

## 旋转

这里以精灵的angle旋转为例。要记住，很多函数是相反的旋转，相关函数会给出独立的说明。

逆时针旋转：增大数，最大365

顺时针旋转：减少数，最小0

## 对应现实世界的时间

计时器的时间和游戏帧（步）同步，比如游戏帧数是60帧，那么每60帧就是一秒。

## 文字显示原理

文字显示原理是GMS事先把用到字体都生成为透明图片，然后放到游戏里。

## 实例ID

GML中，任何实例ID都是一串数字，尽管在编辑器里混合的英文字母。

## 颜色

在GML中，白色c_white也有不干涉颜色的意思。很多地方这么写是填补颜色参数，代表我不需要颜色相关功能。

## 视口、相机是什么

新手容易搞混。因为它们互相有一定影响。配合不好画面就变形。所以正常情况下它们设置一样的数值。比如800x600,1366x768。

- 相机：camera。就是游戏引擎里的传统概念，负责玩家看到的内容，玩家看到的相机内视野也叫view。camera和view不太需要区分。引擎共有7个相机，一般就用到1-3个。
- 视口：window。视口是翻译后的叫法，视口就是windows，Linux游戏时那个窗口大小。



## 白色参考线不代表地图密度

房间编辑界面有白色线进行划分，你的操作也会被这些线影响而对齐。但这只是参考线而不是精、密度的限制。你可以点击右上角关闭参考线，再次点击又可以返回默认状态。

## 图层

图层和作图软件的概念一样，出现在引擎里的房间界面和精灵编辑等界面。它只是图像的层级不影响碰撞等实际交互行为。在房间room中，instance是放是实例用的，background是用笔刷画背景的。还可以添加其他类型的图层。

## 图块集

图块集适合静态物体，只需要很少的CPU资源就可以绘制出来，限制是只能矩形或正方形，当然可以带有透明度的拼合。其他的都要用对象实现。它们只能旋转90°或镜像或翻转，并且只能使用2的幂的帧（即：2、4、8、16等）进行动画处理。 在右侧可以设置画笔的尺寸，稍后在画的时候还可以再手动框选尺寸，最好一开始就做好。绘画时候要专门创建一个图块集的图层。

## 缓冲区

缓冲区，在联机部分提到了buffer。它是在内存中临时开辟的一片区域，速度非常快，目的是提高性能。比如打印机打印速度很慢，我们就把要打印的数据放到缓冲区，让它自己慢慢干。这里cpu就可以休息下来干别的了。通常用来储存非常短期的数据，比如网络发包，快速建立存档。通常建议用完就删除，但是如果不删除则可以存在到游戏关闭。官方文档说，重新启动会导致缓冲区丢失ID句柄而不是删除，最终结果是内存泄漏和崩溃。如果要重新启动游戏要确保删除所有缓冲区。这里的重启可能是指那个官方重启函数，不是关闭后重启。

GMS2允许创建四种缓冲区，目的是选择最适合你的。

| 缓冲区类型   | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| buffer_fixed | 固定大小（以字节为单位）的缓冲区。该大小是在创建缓冲区时设置的，无法再次更改。 |
| buffer_grow  | 缓冲区将随着添加数据而动态增长。您使用初始大小创建它（该大小应该是预期要存储的数据大小的近似值），然后它将扩展以接受更多溢出该初始大小的数据。 |
| buffer_wrap  | 数据将包裹的缓冲区。当所添加的数据达到缓冲区大小的限制时，覆盖将被放回缓冲区的开头，并且从该点开始将继续写入。 |
| buffer_fast  | 这是一个特殊的“向下精简”缓冲区，读取/写入速度非常快。但是它只能与 `buffer_u8`数据类型，并且必须对齐1个字节。 （有关**数据类型**和**字节对齐的**信息，可以在此页面的下方找到）。 |

创建缓冲区的实际代码是这样的：

```c
buf = buffer_create(16384, buffer_fixed, 2);
//第一个是缓冲区增大小，第二个是缓冲区类型为固定的，第三个是缓冲区的数据类型为字节对齐2。
//返回一个唯一ID，用变量buf接收
```

缓冲区按照顺序写入和读取。

以下是缓冲区的数据类型：

| 缓冲区数据类型 | 字节数 | 描述                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| buffer_u8      | 1个    | 一个无符号的8位整数。这是从0到255的正值。                    |
| buffer_s8      | 1个    | 有符号的8位整数。可以是-128到127之间的正值或负值（0被分类为正值）。 |
| buffer_u16     | 2      | 一个无符号的16位整数。这是从0-65,535的正值。                 |
| buffer_s16     | 2      | 有符号的16位整数。可以是-32,768到32,767之间的正值或负值（0分类为正值）。 |
| buffer_f16     | 2      | 一个16位浮点数。这可以是正值或负值，范围为+/-65504。 **（当前不支持！）** |
| buffer_u32     | 4      | 一个无符号的32位整数。这是从0到4,294,967,295的正值。         |
| buffer_s32     | 4      | 有符号的32位整数。这可以是正值或负值，范围是-2,147,483,648至2,147,483,647（0分类为正值）。 |
| buffer_f32     | 4      | 一个32位浮点数。这可以是正值或负值，范围为+/- 16777216。     |
| buffer_u64     | 8      | 一个64位无符号整数值。 **（当前不受所有缓冲区功能的支持！）** |
| buffer_f64     | 8      | 一个64位浮点数。                                             |
| buffer_bool    | 1个    | 布尔值。只能是1或0（`true`或者 `false`）                     |
| buffer_string  | 不适用 | 这是UTF-8空终止（0x00）字符串。基本上，将GameMaker字符串转储到缓冲区中，并在末尾添加0。 |

写入缓冲区，前提是已经创建好了。

```c
//这里的buff是保存缓冲区ID的变量名，第二个是缓冲区数据类型，第三个是要写入的内容
buffer_write(buff, buffer_bool, global.Sound);
buffer_write(buff, buffer_bool, global.Music);
buffer_write(buff, buffer_s16, obj_Player.x);
buffer_write(buff, buffer_s16, obj_Player.y);
buffer_write(buff, buffer_string, global.Player_Name);
```

读取缓冲区。一定要按照同样的顺序来读取。

```c
global.Sound = buffer_read(buff, buffer_bool);
global.Music = buffer_read(buff, buffer_bool);
obj_Player.x = buffer_read(buff, buffer_s16);
obj_Player.y = buffer_read(buff, buffer_s16);
global.Player_Name = buffer_read(buff, buffer_string);
```



# GMS常用解决方案



## 使用对象的继承特性来优化工程

在新手开发时你可能会遇到这种问题，你喜欢任何角色碰到墙面都会停下，但是按照以前的知识，只能手动把每个角色包括玩家、怪物甚至是子弹都和墙面绑定。但这么做完全没必要，想要写出完美的代码是不现实的，特别是需求三天两头变化的游戏行业，但为了你和项目成员的美好生活，你需要至少坚持这一件事——消除重复。并且消除重复是比较简单轻松的。

现在创建一个新的对象，把所有角色包括玩家、怪物、子弹，都拖放到这个新对象的子类里。这个对象仅用于作为父类并不需要拖放到房间中就能生效，仅把这个父类对象和墙面的碰撞绑定就可以了。你可以建立复杂点的父子关系来更精准的处理继承关系，即有儿子、父亲、爷爷、曾爷爷。新手在使用时只需要做好一层继承就可以了。当做复杂工程时，自然会强迫你使用更复杂的继承。你不能指望单用继承就能把复杂的项目就管理的舒适，而是要有好的程序框架思想，才是更重要的消除重复的方法。



注意，子只能只能继承父的以下内容：

- 对象属性
- 事件



## 制作有限状态机

状态机用于AI和简化逻辑。最好配合枚举使用，他们是很好的搭档。

- 定义状态。为哥布林建立4个状态——追踪、冲刺、攻击、撤退。
- 每种状态下会做什么行为。例如“追踪”状态下，是向玩家角色所在的方向移动。
- 状态的切换。在“追踪”状态下，当与玩家角色的距离小于一定数值时，切换至“冲刺”状态。
- 状态切换时的行为。例如从“追踪”状态切换到“冲刺”状态时，是不是需要给角色播放一个大喝一声的音效呢？

有限状态机的实现方式非常灵活，最简单的一种就是将枚举类型与 `if-else` 语句配合使用。

首先在脚本 `Devil(译：恶魔)Create`中制作枚举类型并声明枚举变量，并将初始状态设置为“追踪”：

```c
enum DevilState{
    DEVIL_FOLLOW,    //追踪
    DEVIL_DASH,    //冲刺
    DEVIL_ATTACK,    //攻击
    DEVIL_RETREAT    //撤退
}
m_devilState = DevilState.DEVIL_FOLLOW;  
```

然后就是整个AI行为控制的主循环：

```c
if(m_devilState == DevilState.DEVIL_FOLLOW){
    DevilUpdateFollow();
}
else if(m_devilState == DevilState.DEVIL_DASH){
    DevilUpdateDash();
}
else if(m_devilState == DevilState.DEVIL_ATTACK){
    DevilUpdateAttack();
}
else if(m_devilState == DevilState.DEVIL_RETREAT){
    DevilUpdateRetreat();
}    
```

## 多人联网

此处将会给出一个现成的解决方案。不过你应尽可能多的了解以下内容，以便做出更好联网游戏。且你需要腾出一天的时间来学扎实多人联网相关的内容。这并不是说多人联网很难，而是网络架构要在游戏一开始就搭建，如果你做到游戏中后期，各种功能画面效果都做好了，结果发现网络方案根本不能用，那么就麻烦了。换句话说，对于网络技术，不推荐你边做项目边学。

- 明白联网方案中的TCP和UDP什么意思
- 明白数据同步方案中的帧同步和状态同步什么意思
- 掌握需要用到的函数。
- 掌握相关数据结构，即缓冲区和列表。

什么是联网方案什么是数据同步方案？联网方案就是通过什么方法让多个机器连接到一块，和游戏逻辑无关。而数据同步是，如何让所有联机者的游戏世界内容、画面是一致的。这两个技术中任何一个做不好都不能成功做出多人联网游戏。



联机方案：

联机方案被称为套接字，有TCP和UDP两种选择，TCP延迟较高但却简单。这里先写TCP。

- TCP：一群火车。前面的火车出现了故障，后面的车也必须等待他慢慢走。最后不会丢包，但是慢。因为过程是安全有序的无法干涉，所以技术上简单。几乎可以做到，无需明白发包相关的具体原理，只需要管理发送什么数据，和接收后数据后怎么操作。
- UDP：一群汽车。哪个数据包更快谁就跑的快，达到终点后可以根据之前的编号来确定谁前谁后。要写一套完整的判断规则，所以困难的多。



数据同步方案——帧同步和状态同步：

> 你有没有想过，我的朋友小明玩的是猎空，为什么他按了一下W键。在我的电脑上就可以看到他的猎空向前走了一步？新手请思考两分钟。

在帧同步中，服务器只转发操作并不参与逻辑运算，它把小明的W键信号接收到后，再把W发送给包括小明在内的所有玩家，所有玩家的电脑上就会切换到猎空角色（尽管你的视角不会变，因为是后台完成的），然后模拟按一下W前进。总结一下，当小明按了W后是先发送信号给服务器，然后接收到服务器的W后自己再移动，绕了一圈又回来了。帧同步延迟低，而且服务器配置成本也低，但是服务器不参与计算，导致外挂很轻松制作出来。

在状态同步中，小明的W键又经历了什么呢？状态同步更像是云游戏，从一种逻辑不正确的角度讲，玩家并不在游戏世界里。游戏世界里只有服务器自己。当小明按W键然后把W键发送给服务器的时候，服务器就把游戏世界的里的猎空往前移动一格。然后每逢几毫秒，就把整个游戏世界里的所有玩家的x,y位置，武器状态，子弹位置等都告诉每个玩家电脑，那些电脑就按照这些数据把模型等摆放到对应位置。玩家电脑上那个游戏程序只是个服务器那边的镜像、影子。因此外挂很难开发。状态同步延迟较高，对服务器配置要求也高。如果要认真做出标准的状态同步服务器，比如独立的无画面服务端，那么对于开发者的服务器架构知识储备也有一定要求。

最后，要知道两种的优缺点。比如中途加入，状态同步几乎不需要额外处理，随时来随时玩，因为每过几毫秒所有数据都要同步一次。但帧同步就很麻烦了，中途进来的电脑根本不知道之前发生了什么。还有，帧同步的一个显著难点就是如何保证所有玩家看到的画面都是一致的。不过听说软件行业有些联机方案是不能这样用帧同步和状态同步简易区别的，此处也只是给GMS新手科普一下，不要特别在乎。



作者提供了一套简易的TCP+状态同步的范例用于学习，约95%的内容都是你之后需要用到的。沉下心来就能学会，多人联机的变量数据值会经过多此倒腾，为了增加人眼可读性最好还要用嵌套、枚举辅助。新手学习起来可能胃也跟着倒腾的要吐。不要被这些表象迷糊，捋一捋还是那一点东西。如果你喜欢帧同步，就是修改为按逻辑帧处理数据包的思想，具体请自行解决，欢迎帮忙补充。

先创建一个主菜单的房间，然后创建一个主菜单控制器的对象。在这里就要给对象分好组了，主菜单、服务端、客户端、通用对象各一组。因为联网游戏一般都是中大型工程。在主菜单控制器里写好，按F1进客户端，按F2进服务端。并且用一个全局变量记录下用户选择身份。

接下来到达一个通用房间，现在创建四个对象：服务端、服务端控制器、客户端、客户端控制器。然后在房间创建事件里根据之前记录的玩家身份比如玩家选择的是服务端，就把服务端和服务端控制器创建出来。当然也可以单独在一个通用控制器里的创建事件里写这些代码。为什么要区分诸如服务端和服务端控制器两种的。还是因为提高人类的可视度，代码写在一块比较乱，服务端用来处理关键联网逻辑，服务端控制器用来处理准联网逻辑。看个人喜好，比如我是让服务端处理开服、配置服务器、发包、接包。让服务端控制器处理再后来的操作。

接下来暂时分开编写服务端和客户端代码了。在服务端的创建事件里，写下这些命令。此处注释比较稀疏，因为在常用函数篇里我已经写了network联网和async异步联网的函数了。如果你还去看看官方文档，建议看英文版，因为多人联网太不具象，已经机翻的不是人话了。

```c
//duiXiang_fuWuDuan的创建事件


global.lianJieChengGong = false;							//初始化是否和客户端连接成功
network_set_config(network_config_connect_timeout, 1000);	//初始化最大等待时间，不超过1000帧。非必要
network_create_server(network_socket_tcp,250,10)			//开始开服，端口250，最大允许10个机器连接
keHuDuanLieBiao = ds_list_create();							//创建一个列表数据结构，用来保存当前在线的客户端socket的ID。如果你还没学就去相关篇学会。使用列表数据结构可以说是必须的，因为服务端要发送数据给每个客户端，如果不用列表保存各个上线的玩家ID，那么你要发送给谁呢？在编程阶段，你肯定不会知道会有哪些玩家会连接服务器吧。
```

```c
//duiXiang_fuWuDuan的步事件
//在这个事件里，是服务端按照一定频率给所有客户端发送数据。在本案例中没有定义多长事件发送一次，所以发送速度就和步事件的触发频率一样，每帧发送一次。如果游戏项目设置为60帧。那1帧就是0.01秒发送一次。也就是10ms，这种频率太快了除了局域网都不适合用。

if (global.lianJieChengGong = true){							//这个变量的判断操作你会在之后看到。

//创建缓冲区然后压入数据，讲解省略。这里我们只发送一个名为ceShi的小球的x,y位置。
var buf = buffer_create(10000,buffer_fixed,2);					
buffer_seek(buf,buffer_seek_start,0);

buffer_write(buf,buffer_u16,duiXiang_ceShi.x);
buffer_write(buf,buffer_u16,duiXiang_ceShi.y);


	for (var i = 0; i < ds_list_size(keHuDuanLieBiao); i++)			//利用循环发送给每个在列表的服务端socketID
	{
		var ID = ds_list_find_value(keHuDuanLieBiao,i)
		network_send_packet(ID,buf,buffer_get_size(buf));
	}

    
//删除这一帧的缓冲区，必须要做。因为buf保存的是缓冲区ID，就像你用一个变量记录了一个实例ID一样。之后又为该变量赋值了新的ID，但之前的实例怎么可能受到影响。
buffer_delete(buf);											
buf = -1;
 

}

```

```c
//duiXiang_fuWuDuan的异步事件。
//在这个事件里，是服务端接收到客户端的信号后会处理接收数据等操作。不要被异步这个奇怪的名字干扰，我最开始打算给新手科普异步的基本概念但根本不用像科班学生一样深入学习异步，后来发现根本不用科普。这个事件说白了，就是服务端如何接收数据包，相对于步事件是如何发送数据包。


map = async_load;						//用map接收异步数据
xinHao = ds_map_find_value(map,"type")	//在map数据结构里查找type的值，保存到xinHao里。这是对方发来的信号

switch(xinHao){								//对type即信号进行判断

	case network_type_connect:			//如果是客户端上线了，就设置为连接成功，并把该客户端ID保存进列表
	{
		global.lianJieChengGong = true;
		ds_list_add(keHuDuanLieBiao,ds_map_find_value(map,"socket"));
		break;
	}
	
	case network_type_disconnect:			//如果是客户端下线了，就把该客户端ID从列表删除
	{
		var weiZhi = ds_list_find_index(keHuDuanLieBiao,ds_map_find_value(map,"socket"));
		ds_list_delete(keHuDuanLieBiao,weiZhi);
		break;
	}
	
	case network_type_data:					//如果是客户端发来数据了，就建立缓冲区接收下来，数据同步到本地房间。
	{
		var buff = buffer_create(10000,buffer_fixed,2);
		buff = ds_map_find_value(map,"buffer");	
		buffer_seek(buff, buffer_seek_start, 0);		//这里用了buff，是因为不想和步事件的buf重名。
		
		global.qian = buffer_read(buff,buffer_u16);
		global.hou = buffer_read(buff,buffer_u16);
		global.zuo = buffer_read(buff,buffer_u16);	
		global.you = buffer_read(buff,buffer_u16);	
        
        //到了此处你作为服务端，已经得知了客户端的WASD按键的按住或松开状态，那么之后的服务端逻辑操作就正常编代码落实操作，和多人联网暂时无关了。
        
		buffer_delete(buff);//删除很重要
        buff = -1;
		
		break;
		
	}
	
}



```

现在来编写客户端，客户端的活比较简单。和服务端模块大体类似，在创建事件里配置好本机账号ID用于和服务器连接，然后连接服务器。在步事件里向服务端发送自己的按键状态，在异步事件里接收服务器发来的最终数据。接下来看看代码吧。

```c
//duiXiang_keHuDuan的创建事件

global.lianJieChengGong = false;								//初始化是否和服务端连接成功
socket = network_create_socket(network_socket_tcp);				//创建一个用于tcp访问的socketID
network_connect(socket,"127.0.0.1",250);						//开始连接服务端

// 先初始化按键变量变量，其实在服务端一些变量也需要初始化的，不然程序会报错。到时候自己一看就知道了。因为占用篇幅会让新手误认为代码一大堆很复杂，就没有写。以及，这里使用了枚举，枚举是我在另外一个地方定义好的。anJian.songKai实际上是数字1，anJian.anZhu实际上是数字2。

qian = anJian.songKai;
hou = anJian.songKai;
zuo = anJian.songKai;
you = anJian.songKai;
```

```c
//duiXiang_keHuDuan的步事件

if(global.lianJieChengGong == true){
	
	//从这里开始处理，发送本地按键映射给服务器
	//前后左右移动
	
	if(keyboard_check(ord("W"))){qian = anJian.anZhu};
	else{qian = anJian.songKai};
	if(keyboard_check(ord("S"))){hou = anJian.anZhu};
	else{hou = anJian.songKai};	
	if(keyboard_check(ord("A"))){zuo = anJian.anZhu};
	else{zuo = anJian.songKai};	
	if(keyboard_check(ord("D"))){you = anJian.anZhu};
	else{you = anJian.songKai};

	
	//创建缓冲区、压入数据、发送包
	
	var buf = buffer_create(10000,buffer_fixed,2);
	buffer_seek(buf,buffer_seek_start,0);

	buffer_write(buf,buffer_u16,qian);
	buffer_write(buf,buffer_u16,hou);
	buffer_write(buf,buffer_u16,zuo);
	buffer_write(buf,buffer_u16,you);

	
	network_send_packet(fuWuDuan_ID,buf,buffer_get_size(buf));

	buffer_delete(buf);
    buf = -1;
	
	
}
```

```c
//duiXiang_keHuDuan的异步事件

map = async_load;							//让map接收异步数据
xinHao = ds_map_find_value(map,"type");		//用type接收信号
fuWuDuan_ID = ds_map_find_value(map,"id")		//得到服务器的socket_ID
global.lianJieChengGong = true;					//只要有异步事件就肯定连接成功了


switch(xinHao){
	
	case network_type_data: //如果是客户端发来数据了。这里没必要判断上线下线，毕竟一般只连接一个服务器。
	{
		var buff = buffer_create(10000,buffer_fixed,2);
		buff = ds_map_find_value(map,"buffer");
		
        //完成整个服务端最终点的同步操作。
		duiXiang_ceShi.x = buffer_read(buff,buffer_u16);
		duiXiang_ceShi.y = buffer_read(buff,buffer_u16);
        
		buffer_delete(buff);
        buff = -1;
		break;
	}
	
}
```

最后整理一下思路。在这种简易的状态同步下，共有两组流程，互相交叉。第一组和客户端的步事件和服务端的异步事件。这一组处理的是按键，客户端发送按键，服务端记录下按键进行之后的逻辑处理。另外一组处理的是同步，服务端把游戏世界里的各种实例的状态发送给客户端，客户端接收到后按照服务端的数据进行摆放完成同步。可以说它们的时间并不是交错的，而是先执行第一组，再执行第二组。

## 让游戏支持汉字

第一种方法：
GMS不直接直接中文。搜索国标一级字库，复制3755个汉字，到GMS字体中创建字体，点击添加新的范围，创建后只有大小英文，先点击一下正常让英文正常。在一行粘贴进那些汉字，点增加范围。
加载进来的字体是一张张图片的形式。因此字号越大占用硬盘越大，编译越慢。优点是省事。
在obj_game的创建事件中写`draw_set_font(font0);`

第二种方法：
只添加代码中出现的汉字。新建一个字体，选择从代码中添加，会只把使用过的字体放进来。缺点是麻烦一点，每次改动都添加一次。

## 如何让每个实例显示不同的外观

更换对象的精灵就可以，即一个对象有好几个精灵备用，比如移动中的，跑动中。

```c
sprite_index = spr_wanjia_paobuzhong //译：精灵序列 = 玩家跑步中的那个精灵
    //这里的index好像不应该叫序列，因为是精灵选择层面的函数。有一个image_index那个才是对单个精灵进行序列选择。
```

如果画面很简单，可以只切换一个精灵的帧画面。初始化时先停止动画默认的播放状态。`image_speed = 0 ;`以后用`image_index = 0或1或2自定义显示的序列 ;`

可以用image_xscale才调整朝向，-1是朝左，1是朝右边。它原本是调整缩放的，但是负数却有这种用途。这就减少了素材工作量。不过也可以进行简单编辑，只是一个镜像而已。

## 使用物理学功能

2D游戏不像3D游戏那么复杂的物理，2D需要以下物理功能：

1. 具有空间体积的物体不能占据重叠的空间
2. 物体间发生碰撞后的事件通知

对应到游戏系统的实际内容举例来说就是：

1. 人不能走进墙里
2. 子弹打到人了通知我

在对象面板中打开使用物理Uses Physics，可以看到相关属性。在这里只需要用到密度。对于固定位置的物体，应当密度设置为0，对人物来说保持默认0.5就好了。

下面的三个勾选框。

- “传感器模式”打开后，该物体将不会与其他物体发生碰撞，而仅仅是检测是否有物体进入，因此适合用于作为游戏的触发器。例如玩家走进一个特定区域后触发剧情等。
- “初始唤醒/初始激活”是默认选中的，即从房间被创建时这个物品的物理特性就开始发挥作用。
- “动力学模式/运动的”在打开后，将使该物体不受外界影响，例如重力及其他物品的碰撞。但作用在物体本身的力、加速度及速度依然遵守动力学规律。

要想让物理生效，先把房间也就是游戏的舞台允许物理才行。首先要勾选房间是一个物理房间，其次如果不是做魂斗罗那种游戏，就把y的重力从10改为0，不需要重力存在。

激活物理后，就不能用x，y来移动了，而是被物理世界模拟接管。把原来的xy替换为phy_position_x` 和 `phy_position_y。

和其他引擎不同，开发者必须设定哪些物体之间有碰撞关系，才能产生碰撞效果，哪怕不写碰撞后的代码。

完成后，碰撞会歪斜，如果你不喜欢这个效果。要在那些密度不是1的东西的创建事件中写

```c
phy_fixed_rotation = 1; //译：物理的固定旋转 = 1
```

到了这里已经做了开头，接下来就请自行查找物理相关函数。





## 通过设置固体来简易制作障碍

把对象设置为固定，游戏就会不断把对方移动到碰撞之前的位置。适合做墙壁。但要记住必须添加碰撞事件，告诉GMS那些物体可以碰撞，就算你不写代码。不然程序一律不处理。

## 制作按钮、文本输入的编辑框

GMS不像godot，UE4一样有现成的功能，但是做出来很简单。

制作按钮时，不需要制作多个对象。你只需要制作一个按钮控制器（像其他控制器一样不放置精灵，只是拖到房间里产生作用）。随后在按钮控制器的创建事件里，用instance_create函数在需要位置创建任意数量的按钮，别忘了保留住它们的ID，比如anNiu_kaiShiYouXi，anNiu_tuiChuYouXi，不然之后就不知道谁是谁，没法判断了。最后在绘制事件里逐个进行with(ID)，在自己的x,y位置上绘制出不同按钮文本。现在，我们切换到按钮对象上，这里的代码更简单，只需要一个鼠标按下事件，随后判断自己是哪一个ID，做出相应操作。



get_string是一个默认的文本输入功能，但是他比较丑陋且会单独弹窗出来。除非你开发硬核游戏不然会严重影响美工效果。这里我们继续自制。

制作编辑框时，很多东西和按钮相同。要用到keyboard_string函数，它可以记录之前输入的很长一段字符。

```c
neiRong += keyboard_string;					//neiRong就是编辑框目前显示的内容
keyboard_string = ""; 						//每帧都要删除一次键记录，不然会堆叠不能正常实用。

// 退格删除的功能也是很重要的，实现很简单。

if(keyboard_check_pressed(vk_backspace))
{
neiRong = string_copy(neiRong, 0, string_length(neiRong)-1);	//这串代码会删除内容的最后一个内容
}

// 回车换行功能，可以选择性制作。

if(keyboard_check_pressed(vk_enter))
{
neiRong += "\n";
}
```



## 让游戏可以存档

### 用game_save方式存档和读档

有三种方法。用函数game_save()。用ini配置文件。用ds_map/ds_list储存。

game_save()可以保存静态内容如变量。但不能保存动态内容比如数据结构。不同游戏版本之间不兼容。适合简单的小游戏。

```c
game_save("save.dat") //只需给一个字符串名
game_load("save.dat")
```

### 用ini方式存档和读档

之前说过自带的game_save函数。ini是最普遍的开发者的存档解决方案。其过程透明、可控性高、操作也简单。我建议凡有一点编程基础的人就使用这种方法。

```c
代码详见GML语言的常用函数篇的外部文件操作ini部分。很简单的几条函数。
```



### 用ds_map方式存档和读档

它类似于ini。但有默认的加密，不容易被普通玩家修改。

```c
// ds_map存档 //
save_1 = ds_map_create(); //创建一个ds_map保存到save_1变量中

ds_map_add(save_1,"Head",hero_head);// 在save_1中增加一个key为"Head"的数据，值为hero_head
ds_map_add(save_1,"Right Hand",hero_right_hand);//同上
ds_map_add(save_1,"Left Hand",hero_left_hand);//同上
ds_map_add(save_1,"Level",hero_level);//在save_1中增加一个key为“Level”的数据，值取hero_level对应的值
ds_map_add(save_1,"HP",hero_hp);//同上
ds_map_add(save_1,"Attack",hero_attack);//同上

ds_map_secure_save(save_1, "save1.dat" ) ;//把save_1中的ds_map保存为一个名为"save1.dat"的物理文件
ds_map_destroy(save1.dat);//释放内存
```

```c
// ds_map读档 //
load_save = ds_map_secure_load("save1.dat")//加载"save1.dat"文件中的ds_map保存到"load_save"中

//加载ds_map中的数据保存到游戏变量中
hero_head = ds_map_find_value(load_save, "Head");
hero_right_hand = ds_map_find_value(load_save, "Right Hand");
hero_left_hand = ds_map_find_value(load_save, "Left Hand");
hero_level = ds_map_find_value(load_save, "Level");
hero_hp = ds_map_find_value(load_save, "HP");
hero_attack  = ds_map_find_value(load_save, "Attack");

ds_map_destroy(load_save);//释放内存
```



## 常用快捷键

全局查找替换shift+F。在代码里查找替换ctrl+F。搜索资产资源ctrl+T。最近使用的工作区ctrl+TAB。

中键：有不会的代码，在上面点击鼠标中键会跳到帮助文档。如果不想用浏览器打开，要在偏好设置里常规设置-帮助可以关掉。
右键：注释所选内容。向内向外缩进。代码片段if，for，#region等。双列模式可再拖进来一篇脚本。转换成dnd蓝图。

## 更换IDE显示字体

找到defaults文件夹，用记事本打开里面的那个.json文件，可以看到字体和字号。如果要修改，建议使用微软雅黑字体，调高点字号，因为默认的有点小费眼。

## 脚本注释

脚本注释告诉函数注释，让你在输入函数时不用猜，下面有提示。适合大工程，具体自己去找找。

## 游戏的设置

在资源栏找到游戏选项-，点进去后可设置帧率，针对各个平台进行的调整。如果你做的不是像素游戏，可以去那里打开对像素颜色进行插值来增加画面效果。

## 自带的画图工具挺好用

若没美工，建议自己在GML直接画。

## 变量定义功能

GML有一个专门做变量的窗口，叫变量定义，意义不明。

## 模拟事件发生

有一个叫做ev_系的常量，输入它就可以模拟某个事件发生，但它的兼容性不是特别高，系统不会真正承认它按下了，只是触发相应事件，大概是这样，

在官方文档汉化名称为生产对象事件里，event_perform有大量列表说明各种事件如何模拟。

## 注释要有好习惯

注释分为普通注释和函数的参数注释，要做到注释单独占用一行，代码也是，不要随随便便写到一行里去。代码和工程文件是写以后的自己和给人看的，不要为了使用简写而加重了阅读和理解的负担。

在脚本也就是函数中，开头写/// @param 参数1，参数2，参数3。用来提示参数内容是什么。

## 调试游戏

在代码的左边点出红色的断点，然后进入调试模式。游戏进入后会在断点暂停，这时候可以查看各种变量的值。靠上方有调试时的流程控制按钮。

## 禁用引擎联网来秒开软件

GMS用户是典型的正版软件受害者。有意义不明的联网验证，我之前也聊过因为这个原因考虑过不给GMS免费打工。要秒开软件的方法就是禁止GMS联网。通过任何防火墙软件均可，比较好用的有火绒杀毒软件。如果你实在不想装也可以捣鼓下系统自带的防火墙。要注意，每过一段时间就要放开一次联网权限让他联网验证一次来验证。无论你是否讨厌GMS官方的态度，都不要用破解版软件，因为其较大的病毒捆绑风险，是对你和你的游戏玩家不负责。

---

# 常用的英语

此部分建议直接翻译，翻译三遍、四遍后就记住了。因在实用环境下很容易记在脑子里。一定要敢于翻译，不要手懒。

direction：方向，内部指对象的方向而不是表面图片的方向。

instance：实例。是最终出现在地图上的骷髅1，骷髅2，骷髅3

object：对象或称物体，是用于创建实例的模板，用于创建骷髅1，2，3这样的实例，本文开头讲过。



**函数常用英语：**

> 函数有些规律可寻，找到后你就可以用很少的词汇量快速看懂函数了，比如以下：



```c
exists：存在。验证某某是否存在

create：创建某某

destroy：销毁。一般用于实例的删除。销毁某某，就是把它不再存在。

delete：删除。一般用于资源比如对象，字体的删除。
    
clear：清空。清空某个东西里面的所有内容，但不会删除东西本身。

get：得到。得到某某的什么数据，一般get后面还会继续有内容，且一定会有返回值

sequence：替换

add：增加某某东西

speed：调整某某速度的，比如移动速度，动画播放速度。

width/height：某某的宽度和高度

size：尺寸。注意GMS里width,height和尺寸size好像是不一样的概念。

raw：生的，未加工的。往往都是一些更加底层的函数。对应的有GML更高度封装后的懒人函数，也是常用的。之所以会有_raw函数，一些原因是为了照顾GMS外的扩展功能。
    
ext：扩展。大概是比普通的函数功能多一点。
    
full：完整的功能。这些函数版本有大量的参数可以使用。
```





# 参与维护

为本手册采用了社区协同维护的方式，因为该手册还有很多完善的空间。本手册欢迎所有人参与维护，也欢迎大刀阔斧的对手册结构进行改动，前提是认真负责。

你要是搬运本手册的内容，自己另外写一篇手册，那也是一个不错的选择。前提是对文档结构不满意，或者感觉手册太照顾新手了用起来不够方便，不然维护这一本不是更好吗？

手册中很多地方，写着大概、可能、具体详见文档。这些地方都是明显需要维护的。如有能力，请帮忙维护一下。当然有极个别的详见文档是因为内容太多，文档机翻质量够看，贴上了不简洁，所以就指向文档了。对比各种源码和官方文档，也能很清楚的方向本文档在哪些地方缺乏侧重性，就去补充上。建议有心人士多少能参与一点，哪怕只是讲解清楚一个函数，就能避免一个独立游戏作者花费很长时间翻寻答案，做乏味的调试测试。













